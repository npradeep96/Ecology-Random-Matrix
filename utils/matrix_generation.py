"""
Module that contains functions to generate many different species interaction models
"""

import numpy as np
import scipy.linalg as spl


### Class definitions for matrices associated with different linear models

class random_interaction_model:
	"""
	Class definition for a random interaction model for the ecosystem. This model takes in four parameters as described below and generates the community matrix :math:`W`.

	:param N: Number of species in the ecosystem 
	:param C: Connectance of the graph of interactions. This is the probability that the off-diagonal elements of the adjacency matrix is non-zero.
	:param sigma: Standard deviation of the gaussian distribution from which the interaction strengths are sampled.
	:param d: Strength of the self regulation. This is added as a diagonal element in the community matrix. 
	:type N: int
	:type C: float
	:type sigma: float
	:type d: float

	:ivar N:
	:vartype N: int
	:ivar C: 
	:vartype C: float
	:ivar sigma: 
	:vartype sigma: float
	:ivar d: 
	:vartype d: float
	:ivar adjacency_matrix: Adjacency matrix capturing the network of species-species interactions. This is generated by the function ``adjacency_matrix()``
	:vartype adjacency_matrix: boolean numpy 2darray
	:ivar community_matrix: Community matrix containing pairwise interaction strengths between each pair of species. This is generated by the function ``community_matrix()``
	:vartype community_matrix: float numpy 2darray

	"""
		
	def __init__(self, N, C, sigma, d):
		self.N = int(N)
		self.C = C
		# ensure that the value of C is a fraction
		assert self.C >= 0.0 and self.C <= 1.0, (
			"The connectance C supplied has to be a fraction")
		self.sigma = sigma
		self.d = d

	def generate_adjacency_matrix(self):
		"""
		Function that generates an adjacency matrix for a random graph, where each link has a probability :math:`C` of being present, and return the adjacency matrix 

		:return adjacency_matrix: Adjacency matrix of interactions
		:rtype adjacency_matrix: boolean numpy 2darray
		"""
		# convert the elements to 1 with probability C
		adjacency_matrix = np.zeros([self.N,self.N], dtype=bool)
		adjacency_matrix = (np.random.random([self.N,self.N]) <= self.C)
		adjacency_matrix[np.diag_indices_from(adjacency_matrix)] = True
		return adjacency_matrix

	def generate_community_matrix(self):
		"""
		Function that generates a random community matrix of species-species interactions, where each element is drawn from a zero-mean normal distribution with variance :math:`\sigma^2`
		
		:return W: Community matrix associated with this model
		:rtype W: float numpy 2darray
		"""
		adjacency_matrix = self.generate_adjacency_matrix()
		W = np.zeros([self.N, self.N], dtype=float)
		# Sample off-diagonal elements from a gaussian distribution
		non_zero_elements = np.sum(adjacency_matrix)
		W[adjacency_matrix] = (self.sigma
			*np.random.randn(non_zero_elements))
		# Diagonal elements are set to a fixed value
		W[np.diag_indices_from(W)] = -self.d
		return W

class random_predator_prey_model:
	"""
	Class definition for a random predator-prey model for the ecosystem. This model takes in four parameters as described below and generates the community matrix :math:`W`.

	:param N: Number of species in the ecosystem 
	:param C: Connectance of the graph of interactions. This is the probability that the off-diagonal elements of the adjacency matrix is non-zero.
	:param sigma: Standard deviation of the gaussian distribution from which the interaction strengths are sampled.
	:param d: Strength of the self regulation. This is added as a diagonal element in the community matrix. 
	:type N: int
	:type C: float
	:type sigma: float
	:type d: float

	:ivar N:
	:vartype N: int
	:ivar C: 
	:vartype C: float
	:ivar sigma: 
	:vartype sigma: float
	:ivar d: 
	:vartype d: float
	:ivar adjacency_matrix: Adjacency matrix capturing the network of species-species interactions. This is generated by the function ``adjacency_matrix()``
	:vartype adjacency_matrix: boolean numpy 2darray
	:ivar community_matrix: Community matrix containing pairwise interaction strengths between each pair of species. This is generated by the function ``community_matrix()``
	:vartype community_matrix: float numpy 2darray

	"""

	def __init__(self, N, C, sigma, d):
		self.N = int(N)
		self.C = C
		# ensure that the value of C is a fraction
		assert self.C >= 0.0 and self.C <= 1.0, (
			"The connectance C supplied has to be a fraction")
		self.sigma = sigma
		self.d = d

	def generate_adjacency_matrix(self):
		"""
		Function that generates an adjacency matrix for a random graph, where each link has a probability C of being present. In addition, this also imposes the constraint that if a link between :math:`i` and :math:`j` exists, then a link between :math:`j` and :math:`i` exists as well

		:return adjacency_matrix: Adjacency matrix of interactions
		:rtype adjacency_matrix: boolean numpy 2darray
		"""
		# generate pairs of non-zero off diagonal elements with probability C
		size_of_upper_triangle = int(self.N*(self.N-1)/2)
		upper_triangular_entries = np.random.random(size_of_upper_triangle)
		
		# construct adjacency matrix by making an upper triangular matrix of the above list
		adjacency_matrix = np.zeros([self.N,self.N], dtype=bool)
		adjacency_matrix[np.triu_indices(self.N, k=1)] = (upper_triangular_entries <= self.C)
		adjacency_matrix = (adjacency_matrix 
			+ adjacency_matrix.transpose())
		adjacency_matrix[np.diag_indices_from(adjacency_matrix)] = True    
		return adjacency_matrix

	def generate_community_matrix(self):
		"""
		Function that generates a random community matrix of predator-prey interactions. The pairs of off-diagonal elements :math:`W_{ij}` and :math:`W_{ji}` are each sampled independently from a distribution of :math:`|X|` where :math:`X \sim \mathcal{N}(0,\sigma^2)`. It is also ensured that :math:`W_{ij}` and :math:`W_{ji}` have opposite signs.

		:return W: Community matrix associated with this model
		:rtype W: float numpy 2darray
		"""
		adjacency_matrix = self.generate_adjacency_matrix()
		# Initialize the community matrix
		sign_matrix = np.zeros([self.N, self.N], dtype=int)
		W = np.zeros([self.N, self.N], dtype=float)
		
		# Sample a list of elements as |X| where X is drawn from a gaussian distribution
		number_of_non_zero_elements = np.sum(adjacency_matrix)
		non_zero_elements = self.sigma*np.random.randn(
			number_of_non_zero_elements)
		W[adjacency_matrix] = np.abs(non_zero_elements)
		# generate a random string of +1 and -1 for the signs of the upper diagonal elements
		sign_matrix[adjacency_matrix] = 2*(np.random.binomial(
			size=number_of_non_zero_elements, n=1, p= 0.5) - 0.5)
		sign_matrix[np.tril_indices(self.N)] = 0
		sign_matrix = sign_matrix - sign_matrix.transpose()
		# non-zero off-diagonal elements of W matrix are obtained by multiplying the above two matrices
		W[adjacency_matrix] = np.multiply(
			W[adjacency_matrix], 
			sign_matrix[adjacency_matrix])
		
		# Diagonal elements are set to a fixed value
		W[np.diag_indices_from(W)] = -self.d

		return W

class random_mutualism_model:
	"""
	Class definition for a random mutualism model for the ecosystem. This model takes in four parameters as described below and generates the community matrix :math:`W`.

	:param N: Number of species in the ecosystem 
	:param C: Connectance of the graph of interactions. This is the probability that the off-diagonal elements of the adjacency matrix is non-zero.
	:param sigma: Standard deviation of the gaussian distribution from which the interaction strengths are sampled.
	:param d: Strength of the self regulation. This is added as a diagonal element in the community matrix. 
	:type N: int
	:type C: float
	:type sigma: float
	:type d: float

	:ivar N:
	:vartype N: int
	:ivar C: 
	:vartype C: float
	:ivar sigma: 
	:vartype sigma: float
	:ivar d: 
	:vartype d: float
	:ivar adjacency_matrix: Adjacency matrix capturing the network of species-species interactions. This is generated by the function ``adjacency_matrix()``
	:vartype adjacency_matrix: boolean numpy 2darray
	:ivar community_matrix: Community matrix containing pairwise interaction strengths between each pair of species. This is generated by the function ``community_matrix()``
	:vartype community_matrix: float numpy 2darray

	"""

	def __init__(self, N, C, sigma, d):
		self.N = int(N)
		self.C = C
		# ensure that the value of C is a fraction
		assert self.C >= 0.0 and self.C <= 1.0, (
			"The connectance C supplied has to be a fraction")
		self.sigma = sigma
		self.d = d

	def generate_adjacency_matrix(self):
		"""
		Function that generates an adjacency matrix for a random graph, where each link has a probability C of being present. In addition, this also imposes the constraint that if a link between :math:`i` and :math:`j` exists, then a link between :math:`j` and :math:`i` exists as well

		:return adjacency_matrix: Adjacency matrix of interactions
		:rtype adjacency_matrix: boolean numpy 2darray
		"""
		# generate pairs of non-zero off diagonal elements with probability C
		size_of_upper_triangle = int(self.N*(self.N-1)/2)
		upper_triangular_entries = np.random.random(size_of_upper_triangle)
		
		# construct adjacency matrix by making an upper triangular matrix of the above list
		adjacency_matrix = np.zeros([self.N,self.N], dtype=bool)
		adjacency_matrix[np.triu_indices(self.N, k=1)] = (upper_triangular_entries <= self.C)
		adjacency_matrix = (adjacency_matrix 
			+ adjacency_matrix.transpose())
		adjacency_matrix[np.diag_indices_from(adjacency_matrix)] = True 
		return adjacency_matrix

	def generate_community_matrix(self):
		"""
		Function that generates a random community matrix for mutualistic interactions. The pairs of off-diagonal elements :math:`W_{ij}` and :math:`W_{ji}` are each sampled independently from a distribution of :math:`|X|` where :math:`X \sim \mathcal{N}(0,\sigma^2)`. It is also ensured that :math:`W_{ij}` and :math:`W_{ji}` have +ve sign.

		:return W: Community matrix associated with this model
		:rtype W: float numpy 2darray
		"""
		adjacency_matrix = self.generate_adjacency_matrix()
		# Initialize the community matrix
		W = np.zeros([self.N, self.N], dtype=float)
		
		# Sample a list of elements as |X| where X is drawn from a gaussian distribution
		number_of_non_zero_elements = np.sum(adjacency_matrix)
		non_zero_elements = self.sigma*np.random.randn(
			number_of_non_zero_elements)
		W[adjacency_matrix] = np.abs(non_zero_elements)
		
		# Diagonal elements are set to a fixed value
		W[np.diag_indices_from(W)] = -self.d

		return W

class random_competition_model:
	"""
	Class definition for a random competition model for the ecosystem. This model takes in four parameters as described below and generates the community matrix :math:`W`.

	:param N: Number of species in the ecosystem 
	:param C: Connectance of the graph of interactions. This is the probability that the off-diagonal elements of the adjacency matrix is non-zero.
	:param sigma: Standard deviation of the gaussian distribution from which the interaction strengths are sampled.
	:param d: Strength of the self regulation. This is added as a diagonal element in the community matrix. 
	:type N: int
	:type C: float
	:type sigma: float
	:type d: float

	:ivar N:
	:vartype N: int
	:ivar C: 
	:vartype C: float
	:ivar sigma: 
	:vartype sigma: float
	:ivar d: 
	:vartype d: float
	:ivar adjacency_matrix: Adjacency matrix capturing the network of species-species interactions. This is generated by the function ``adjacency_matrix()``
	:vartype adjacency_matrix: boolean numpy 2darray
	:ivar community_matrix: Community matrix containing pairwise interaction strengths between each pair of species. This is generated by the function ``community_matrix()``
	:vartype community_matrix: float numpy 2darray

	"""

	def __init__(self, N, C, sigma, d):
		self.N = int(N)
		self.C = C
		# ensure that the value of C is a fraction
		assert self.C >= 0.0 and self.C <= 1.0, (
			"The connectance C supplied has to be a fraction")
		self.sigma = sigma
		self.d = d

	def generate_adjacency_matrix(self):
		"""
		Function that generates an adjacency matrix for a random graph, where each link has a probability C of being present. In addition, this also imposes the constraint that if a link between :math:`i` and :math:`j` exists, then a link between :math:`j` and :math:`i` exists as well

		:return adjacency_matrix: Adjacency matrix of interactions
		:rtype adjacency_matrix: boolean numpy 2darray
		"""
		# generate pairs of non-zero off diagonal elements with probability C
		size_of_upper_triangle = int(self.N*(self.N-1)/2)
		upper_triangular_entries = np.random.random(size_of_upper_triangle)
		
		# construct adjacency matrix by making an upper triangular matrix of the above list
		adjacency_matrix = np.zeros([self.N,self.N], dtype=bool)
		adjacency_matrix[np.triu_indices(self.N, k=1)] = (upper_triangular_entries <= self.C)
		adjacency_matrix = (adjacency_matrix 
			+ adjacency_matrix.transpose())
		adjacency_matrix[np.diag_indices_from(adjacency_matrix)] = True 
		return adjacency_matrix

	def generate_community_matrix(self):
		"""Function that generates a random community matrix for competitive interactions. The pairs of off-diagonal elements :math:`W_{ij}` and :math:`W_{ji}` are each sampled independently from a distribution of :math:`|X|` where :math:`X \sim \mathcal{N}(0,\sigma^2)`. It is also ensured that :math:`W_{ij}` and :math:`W_{ji}` have -ve sign.

		:return W: Community matrix associated with this model
		:rtype W: float numpy 2darray
		"""
		adjacency_matrix = self.generate_adjacency_matrix()
		# Initialize the community matrix
		shape = np.shape(adjacency_matrix)
		W = np.zeros([self.N, self.N], dtype=float)
		
		# Sample a list of elements as |X| where X is drawn from a gaussian distribution
		number_of_non_zero_elements = np.sum(adjacency_matrix)
		non_zero_elements = self.sigma*np.random.randn(
			number_of_non_zero_elements)
		W[adjacency_matrix] = -np.abs(non_zero_elements)
		
		# Diagonal elements are set to a fixed value
		W[np.diag_indices_from(W)] = -self.d

		return W

class random_mixture_model:
	"""
	Class definition for a random mixture model including competitive and mutualistic interactions for the ecosystem. This model takes in four parameters as described below and generates the community matrix :math:`W`.

	:param N: Number of species in the ecosystem 
	:param C: Connectance of the graph of interactions. This is the probability that the off-diagonal elements of the adjacency matrix is non-zero.
	:param sigma: Standard deviation of the gaussian distribution from which the interaction strengths are sampled.
	:param d: Strength of the self regulation. This is added as a diagonal element in the community matrix. 
	:type N: int
	:type C: float
	:type sigma: float
	:type d: float

	:ivar N:
	:vartype N: int
	:ivar C: 
	:vartype C: float
	:ivar sigma: 
	:vartype sigma: float
	:ivar d: 
	:vartype d: float
	:ivar adjacency_matrix: Adjacency matrix capturing the network of species-species interactions. This is generated by the function ``adjacency_matrix()``
	:vartype adjacency_matrix: boolean numpy 2darray
	:ivar community_matrix: Community matrix containing pairwise interaction strengths between each pair of species. This is generated by the function ``community_matrix()``
	:vartype community_matrix: float numpy 2darray

	"""

	def __init__(self, N, C, sigma, d):
		self.N = int(N)
		self.C = C
		# ensure that the value of C is a fraction
		assert self.C >= 0.0 and self.C <= 1.0, (
			"The connectance C supplied has to be a fraction")
		self.sigma = sigma
		self.d = d

	def generate_adjacency_matrix(self):
		"""
		Function that generates an adjacency matrix for a random graph, where each link has a probability C of being present. In addition, this also imposes the constraint that if a link between :math:`i` and :math:`j` exists, then a link between :math:`j` and :math:`i` exists as well.

		:return adjacency_matrix: Adjacency matrix of interactions
		:rtype adjacency_matrix: boolean numpy 2darray
		"""
		# generate pairs of non-zero off diagonal elements with probability C
		size_of_upper_triangle = int(self.N*(self.N-1)/2)
		upper_triangular_entries = np.random.random(size_of_upper_triangle)
		
		# construct adjacency matrix by making an upper triangular matrix of the above list
		adjacency_matrix = np.zeros([self.N,self.N], dtype=bool)
		adjacency_matrix[np.triu_indices(self.N, k=1)] = (upper_triangular_entries <= self.C)
		adjacency_matrix = (adjacency_matrix 
			+ adjacency_matrix.transpose())
		adjacency_matrix[np.diag_indices_from(adjacency_matrix)] = True 
		return adjacency_matrix

	def generate_community_matrix(self):
		"""
		Function that generates a random community matrix of a mixture of competition and mutualistic interactions. The pairs of off-diagonal elements :math:`W_{ij}` and :math:`W_{ji}` are each sampled independently from a distribution of :math:`|X|` where :math:`X \sim \mathcal{N}(0,\sigma^2)`. The signs of :math:`W_{ij}` and :math:`W_{ji}` are randomly of same sign or opposite sign.

		:return W: Community matrix associated with this model
		:rtype W: float numpy 2darray
		"""
		adjacency_matrix = self.generate_adjacency_matrix()
		# Initialize the community matrix
		sign_matrix = np.zeros([self.N, self.N], dtype=int)
		W = np.zeros([self.N, self.N], dtype=float)
		
		# Sample a list of elements as |X| where X is drawn from a gaussian distribution
		number_of_non_zero_elements = np.sum(adjacency_matrix)
		non_zero_elements = self.sigma*np.random.randn(
			number_of_non_zero_elements)
		W[adjacency_matrix] = np.abs(non_zero_elements)
		# generate a random string of +1 and -1 for the signs of the upper diagonal elements
		sign_matrix[adjacency_matrix] = 2*(np.random.binomial(
			size=number_of_non_zero_elements, n=1, p= 0.5) - 0.5)
		sign_matrix[np.tril_indices(self.N)] = 0
		sign_matrix = sign_matrix + sign_matrix.transpose()
		# non-zero off-diagonal elements of W matrix are obtained by multiplying the above two matrices
		W[adjacency_matrix] = np.multiply(
			W[adjacency_matrix], 
			sign_matrix[adjacency_matrix])
		
		# Diagonal elements are set to a fixed value
		W[np.diag_indices_from(W)] = -self.d

		return W

class random_predator_prey_cascade_model:
	"""
	Class definition for a cascade model for predator-prey interactions for the ecosystem. This model takes in four parameters as described below and generates the community matrix :math:`W`.

	:param N: Number of species in the ecosystem 
	:param C: Connectance of the graph of interactions. This is the probability that the off-diagonal elements of the adjacency matrix is non-zero.
	:param sigma: Standard deviation of the gaussian distribution from which the interaction strengths are sampled.
	:param d: Strength of the self regulation. This is added as a diagonal element in the community matrix. 
	:type N: int
	:type C: float
	:type sigma: float
	:type d: float

	:ivar N:
	:vartype N: int
	:ivar C: 
	:vartype C: float
	:ivar sigma: 
	:vartype sigma: float
	:ivar d: 
	:vartype d: float
	:ivar adjacency_matrix: Adjacency matrix capturing the network of species-species interactions. This is generated by the function ``adjacency_matrix()``
	:vartype adjacency_matrix: boolean numpy 2darray
	:ivar community_matrix: Community matrix containing pairwise interaction strengths between each pair of species. This is generated by the function ``community_matrix()``
	:vartype community_matrix: float numpy 2darray

	"""

	def __init__(self, N, C, sigma, d):
		self.N = int(N)
		self.C = C
		# ensure that the value of C is a fraction
		assert self.C >= 0.0 and self.C <= 1.0, (
			"The connectance C supplied has to be a fraction")
		self.sigma = sigma
		self.d = d

	def generate_adjacency_matrix(self):
		"""
		Function that generates an adjacency matrix for a random graph, where each link has a probability C of being present. In addition, this also imposes the constraint that if a link between :math:`i` and :math:`j` exists, then a link between :math:`j` and :math:`i` exists as well

		:return adjacency_matrix: Adjacency matrix of interactions
		:rtype adjacency_matrix: boolean numpy 2darray
		"""
		# generate pairs of non-zero off diagonal elements with probability C
		size_of_upper_triangle = int(self.N*(self.N-1)/2)
		upper_triangular_entries = np.random.random(size_of_upper_triangle)
		
		# construct adjacency matrix by making an upper triangular matrix of the above list
		adjacency_matrix = np.zeros([self.N,self.N], dtype=bool)
		adjacency_matrix[np.triu_indices(self.N, k=1)] = (upper_triangular_entries <= self.C)
		adjacency_matrix = (adjacency_matrix 
			+ adjacency_matrix.transpose())
		adjacency_matrix[np.diag_indices_from(adjacency_matrix)] = True 
		return adjacency_matrix

	def generate_community_matrix(self):
		"""
		Function that generates a random community matrix of predator-prey interactions according to the cascade model. In the cascade model, the lower triangular elements :math:`W_{ij}` are sampled from a distribution of :math:`|X|` where :math:`X \sim \mathcal{N}(0,\sigma^2)`. The upper triangular element :math:`W_{ji}` corresponding to the :math:`W_{ij}` is sampled from the distribution of :math:`-|X|` where :math:`X \sim \mathcal{N}(0,\sigma^2)`. The

		:return W: Community matrix associated with this model
		:rtype W: float numpy 2darray
		"""
		adjacency_matrix = self.generate_adjacency_matrix()
		# Initialize the community matrix
		W = np.zeros([self.N, self.N], dtype=float)
		
		# Sample a list of elements as |X| where X is drawn from a gaussian distribution for the lower triangle
		number_of_non_zero_elements = np.sum(adjacency_matrix)
		non_zero_elements = self.sigma*np.random.randn(
			number_of_non_zero_elements)
		W[adjacency_matrix] = np.abs(non_zero_elements)
		# make the lower triangle have +ve sign and the upper triangle have negative sign
		W[np.triu_indices_from(W)] = (-1.0
			*W[np.triu_indices_from(W)]) 
		
		# Diagonal elements are set to a fixed value
		W[np.diag_indices_from(W)] = -self.d

		return W

class random_predator_prey_niche_model:
	"""
	Class definition for a niche model for predator-prey interactions for the ecosystem. This model takes in four parameters as described below and generates the community matrix :math:`W`.

	:param N: Number of species in the ecosystem 
	:param C: Connectance of the graph of interactions. This is the probability that the off-diagonal elements of the adjacency matrix is non-zero.
	:param sigma: Standard deviation of the gaussian distribution from which the interaction strengths are sampled.
	:param d: Strength of the self regulation. This is added as a diagonal element in the community matrix. 
	:type N: int
	:type C: float
	:type sigma: float
	:type d: float

	:ivar N:
	:vartype N: int
	:ivar C: 
	:vartype C: float
	:ivar sigma: 
	:vartype sigma: float
	:ivar d: 
	:vartype d: float
	:ivar adjacency_matrix: Adjacency matrix capturing the network of species-species interactions. This is generated by the function ``adjacency_matrix()``
	:vartype adjacency_matrix: boolean numpy 2darray
	:ivar community_matrix: Community matrix containing pairwise interaction strengths between each pair of species. This is generated by the function ``community_matrix()``
	:vartype community_matrix: float numpy 2darray

	"""

	def __init__(self, N, C, sigma, d):
		self.N = int(N)
		self.C = C
		# ensure that the value of C is a fraction
		assert self.C >= 0.0 and self.C <= 1.0, (
			"The connectance C supplied has to be a fraction")
		self.sigma = sigma
		self.d = d

	def generate_adjacency_matrix(self, tolerance=0.01):
		"""
		Function that generates an adjacency matrix for a niche connectivity model. Niche Model (as described in: https://rdrr.io/github/elsander/PredictImportance/src/R/BuildNiche.R)
		
		1. In a niche model, each species is assigned a niche value (:math:`n_i`), which is sampled uniformly between :math:`[0,1]`
		
		2. This niche value (:math:`n_i`) is used to compute a niche radius (:math:`r_i`) where :math:`r_i = X n_i`, where :math:`X \sim Beta(1,1/C-1)`. The above method also ensures that the connectance of the graph is :math:`C` on average. There might be fluctuations about the mean value of :math:`C` for small graphs
		
		3. A niche center (:math:`c_i`) is chosen for each species by uniformly sampling the interval :math:`[r_i/2, min(n_i, 1-r_i/2)]`. The point is to ensure that the interval :math:`[c_i-r_i/2, c_i+r_i/2]` lies entirely within :math:`[0,1]` and is centered around ni on average whenever possible.
		
		4. Each species :math:`i` preys upon all species :math:`j` whose niche values :math:`n_j` belong to the interval :math:`[c_i-r_i/2, c_i+r_i/2]`
		
		5. Using the above model, construct a matrix :math:`A_{ij}` where :math:`A_{ij} = 1` if :math:`i` is a prey of :math:`j`
		
		6. Construct a sign matrix :math:`P = -A + A'`
		
		7. Finally, the community matrix is obtained by multiplying :math:`P` with a random matrix of elements sampled from :math:`|X|` where :math:`X \sim \mathcal{N}(0,\sigma^2)`

		:return adjacency_matrix: Adjacency matrix of interactions
		:rtype adjacency_matrix: boolean numpy 2darray
		"""
		# Initialize adjacency matrix
		adjacency_matrix = np.zeros([self.N,self.N], dtype=int)
		# 1. assign niche values
		n = np.random.random(self.N)
		
		# this loop is to generate different adjacency matrices and accept one that best conforms to the connectance value C
		accept = False
		iter_max = 100
		counter = 0
		while (not accept) and (counter < iter_max):
			# 2. compute niche radii
			beta = np.random.beta(a=1.0, b=1.0/(0.5*self.C)-1.0, size=self.N)
			r = np.multiply(beta, n)
			# 3. get niche center for each niche
			interval_lower_bound = 0.5*r
			interval_upper_bound = np.min([n,1.0-0.5*r])
			c = (np.multiply(np.random.random(self.N), 
				interval_upper_bound-interval_lower_bound) 
				+ interval_lower_bound)
			# 4. make all species in the interval [ci-ri/2,ci+ri/2] as the prey for predator i
			for i in range(self.N):
				prey_indices = (n>c[i]-0.5*r[i]) & (n<c[i]+0.5*r[i])
				adjacency_matrix[prey_indices,i] = 1
			# do quality control to check that the connectance C is the desired value C
			counter = counter+1
			if np.abs(
				np.sum(np.abs(adjacency_matrix))
				/(self.N*(self.N-1.0)/2.0) - self.C) < tolerance:
				accept = True
		if counter == iter_max:
			print("Warning: the adjacency matrix may not be correct!")
			
		# 6. construct sign matrix
		adjacency_matrix = (adjacency_matrix.transpose() 
			- adjacency_matrix)

		return adjacency_matrix

	def generate_community_matrix(self):
		"""
		Function that generates a random community matrix of predator-prey interactions according to the niche model.In the Niche model, the adjacency matrix is generated corresponding the niche algorithm. The individual non-zero elements of the community matrix are generated according to the distribution :math:`|X|` where :math:`X \sim \mathcal{N}(0,\sigma^2)` and multiplying them with the appropriate sign in the signed adjacency matrix.

		:return W: Community matrix associated with this model
		:rtype W: float numpy 2darray
		"""
		adjacency_matrix = self.generate_adjacency_matrix()
		# Initialize the community matrix
		W = np.zeros([self.N, self.N], dtype=float)
		
		# Sample a list of elements as |X| where X is drawn from a gaussian distribution for the lower triangle
		number_of_non_zero_elements = np.sum(np.abs(adjacency_matrix))
		non_zero_elements = self.sigma*np.random.randn(
			number_of_non_zero_elements)
		W[adjacency_matrix!=0] = np.abs(non_zero_elements)
		# make the lower triangle have +ve sign and the upper triangle have negative sign
		W = np.multiply(adjacency_matrix, W)
		
		# Diagonal elements are set to a fixed value
		W[np.diag_indices_from(W)] = -self.d

		return W

class random_mutualism_bipartite_model:
	"""
	Class definition for a bipartite model for mutualistic interactions for the ecosystem. This model takes in four parameters as described below and generates the community matrix :math:`W`.

	:param N: Number of species in the ecosystem 
	:param C: Connectance of the graph of interactions. This is the probability that the off-diagonal elements of the adjacency matrix is non-zero.
	:param sigma: Standard deviation of the gaussian distribution from which the interaction strengths are sampled.
	:param d: Strength of the self regulation. This is added as a diagonal element in the community matrix. 
	:type N: int
	:type C: float
	:type sigma: float
	:type d: float

	:ivar N:
	:vartype N: int
	:ivar C: 
	:vartype C: float
	:ivar sigma: 
	:vartype sigma: float
	:ivar d: 
	:vartype d: float
	:ivar adjacency_matrix: Adjacency matrix capturing the network of species-species interactions. This is generated by the function ``adjacency_matrix()``
	:vartype adjacency_matrix: boolean numpy 2darray
	:ivar community_matrix: Community matrix containing pairwise interaction strengths between each pair of species. This is generated by the function ``community_matrix()``
	:vartype community_matrix: float numpy 2darray
	"""

	def __init__(self, N, C, sigma, d):
		self.N = int(N)
		self.C = C
		# ensure that the value of C is a fraction
		assert self.C >= 0.0 and self.C <= 1.0, (
			"The connectance C supplied has to be a fraction")
		self.sigma = sigma
		self.d = d

	def generate_adjacency_matrix(self):
		"""
		Function to generate the adjacency matrix for a bipartite graph. We split the total number of :math:`N` nodes into two groups, each of size :math:`N/2`. For each pair :math:`(i,j)` where :math:`i` is from group 1 and :math:`j` is from group 2, we make :math:`A_{ij}` and :math:`A_{ji}` non-zero with a probability :math:`2C(N-1)/N`. This ensures that the connectance is :math:`C`.

		:return adjacency_matrix: Adjacency matrix of interactions
		:rtype adjacency_matrix: boolean numpy 2darray
		"""
		# ensure that the value of C is a fraction
		assert self.N%2 == 0, (
			"Please ensure that the number of nodes in the bipartite graph is an even number")
		
		# Initialize adjacency matrix
		adjacency_matrix = np.zeros([self.N,self.N], dtype=bool)
		# Probability of an element in the top right quadrant being non-zero
		p = 2*self.C*(self.N-1)/self.N
		# generate a set of binomial random variables and assign those to the top right quadrant
		adjacency_matrix[0:int(self.N/2), int(self.N/2):] = np.reshape(
			np.random.binomial(
				size=int((self.N/2)**2), n=1, p=p), 
			[int(self.N/2), int(self.N/2)])
		# generate the final adjacency matrix of bipartite mutualistic interactions
		adjacency_matrix = (adjacency_matrix 
			+ adjacency_matrix.transpose())
		adjacency_matrix[np.diag_indices_from(adjacency_matrix)] = True
		return adjacency_matrix

	def generate_community_matrix(self):
		"""Function that generates a random community matrix for bipartite mutualistic interactions between species. Each non-zero element is derived from a distribution :math:`|X|` where :math:`X \sim \mathcal{N}(0,\sigma^2)`.

		:return W: Community matrix associated with this model
		:rtype W: float numpy 2darray    
		"""
		adjacency_matrix = self.generate_adjacency_matrix()
		# Initialize the community matrix
		W = np.zeros([self.N, self.N], dtype=float)
		
		# Sample a list of elements as |X| where X is drawn from a gaussian distribution for the lower triangle
		number_of_non_zero_elements = np.sum(np.abs(adjacency_matrix))
		non_zero_elements = self.sigma*np.random.randn(
			number_of_non_zero_elements)
		W[adjacency_matrix!=0] = np.abs(non_zero_elements)
		# make the lower triangle have +ve sign and the upper triangle have negative sign
		W = np.multiply(adjacency_matrix, W)
		
		# Diagonal elements are set to a fixed value
		W[np.diag_indices_from(W)] = -self.d

		return W

class random_predator_prey_preferential_preying:
	"""
	Class definition for a preferential preying model for predator-prey interactions for the ecosystem as described in https://www.pnas.org/doi/full/10.1073/pnas.1409077111. This model takes in five parameters as described below and generates the community matrix :math:`W`.

	:param N: Number of species in the ecosystem 
	:param C: Connectance of the graph of interactions. This is the probability that the off-diagonal elements of the adjacency matrix is non-zero.
	:param sigma: Standard deviation of the gaussian distribution from which the interaction strengths are sampled.
	:param d: Strength of the self regulation. This is added as a diagonal element in the community matrix. 
	:param T: parameter that determines trophic coherence. A large T means low trophic coherence and a small T means high trophic coherence.
	:type N: int
	:type C: float
	:type sigma: float
	:type d: float
	:type T: float

	:ivar N:
	:vartype N: int
	:ivar C: 
	:vartype C: float
	:ivar sigma: 
	:vartype sigma: float
	:ivar d: 
	:vartype d: float
	:ivar T:
	:vartype T: float
	:ivar adjacency_matrix: Adjacency matrix capturing the network of species-species interactions. This is generated by the function ``adjacency_matrix()``
	:vartype adjacency_matrix: boolean numpy 2darray
	:ivar community_matrix: Community matrix containing pairwise interaction strengths between each pair of species. This is generated by the function ``community_matrix()``
	:vartype community_matrix: float numpy 2darray
	"""

	def __init__(self, N, C, sigma, d, T=0.01):
		self.N = int(N)
		self.C = C
		# ensure that the value of C is a fraction
		assert self.C >= 0.0 and self.C <= 1.0, (
			"The connectance C supplied has to be a fraction")
		self.sigma = sigma
		self.d = d
		self.T = T

	def generate_adjacency_matrix(self, tolerance=0.02):
	    """
	    Function that generates an adjacency matrix for a preferential prey model.
	    Preferential prey model as described in: https://www.pnas.org/doi/full/10.1073/pnas.1409077111
	    1. Start off with one species in the network
	    2. Keep adding species to the network until the total number of species become :math:`$n$`
	    3. There are :math:`$i-1$` species present in the network when the :math:`i^{th}`species arrives. Randomly assign one of the :math:`i-1` species as prey to the :math:`i^{th}`species. Call this species :math:'p'
	    4. Compute the trophic level of each species :math:`j, j= (1,...,i-1)` given a predation matrix :math:`A, A_{jk} = 1' if :math:`k` is the prey of :math:`j` by solving :math:`s_j=1+\Sigma_{k}A_{jk}s_{k}/\Sigma_{k}A_{jk}
	    5. Determine the number of species (:math:`\kappa_i`) to connect to species :math:`i` by generating a beta random variable :math:`x_i \sim Beta(\frac{N^2-1}{2NC}-1,1)` and setting :math:`\kappa_i=(i-1)x_i`
	    6. Compute the array :math:`|s_j-s_p|`, sort it in ascending order, and pick out the first :math:`\kappa_i` elements from this array. Assign them as prey to the species :math:`i`
	    7. Keep repeating until :math:`i` reaches :math:`N`
	    
	    Input:
	    1. C: probability that the off-diagonal elements of the adjacency matrix is non-zero
	    2. N: size of the square matrix
	    
	    Output:
	    1. adj_mat: The function returns the adjacency matrix along with sign. Note that this is a matrix that contains
	                +1, -1 and 0. 
	    """
	    # ensure that the value of C is a fraction
	    assert self.C >= 0.0 and self.C <= 1.0, "The input probability C to the function has to be a fraction"
	    
	    # function to calculate trophic level
	    def calculate_trophic_level(predation_matrix):
	        """
	        Function that calculates the trophic level of each species :math:`j, j= (1,...,i-1)` given a predation matrix :math:`A, A_{jk} = 1' if :math:`k` is the prey of :math:`j` by solving :math:`s_j=1+\Sigma_{k}A_{jk}s_{k}/\Sigma_{k}A_{jk}
	        """
	        shape = np.shape(predation_matrix)
	        N = shape[0]
	        trophic_level = np.ones(N)

	        # compute the in degree for each species
	        k_in_array = [np.sum(predation_matrix[j,:]) for j in range(N)]
	        # find the species for which in degree is non-zero
	        indices = np.nonzero(k_in_array)

	        #generate matrix of coefficients to solve the linear equations
	        N_nonzero = np.size(indices)
	        coefficients = np.zeros([N_nonzero, N_nonzero])
	        b = np.zeros(N_nonzero)
	        for j in range(N_nonzero):
	            prey_accounted = 0
	            for k in range(N_nonzero):
	                # pdb.set_trace()
	                coefficients[j,k] = (1.0*(j==k) 
	                	- predation_matrix[indices[0][j],indices[0][k]]
	                	/k_in_array[indices[0][j]])
	                prey_accounted = (prey_accounted 
	                	+ predation_matrix[indices[0][j],indices[0][k]])
	            b[j] = 1 + (k_in_array[indices[0][j]] 
	            	- prey_accounted)/k_in_array[indices[0][j]] 

	        # solve the linear equations to get trophic level
	        trophic_level_nonzero = spl.solve(coefficients, b)

	        # assign the solved values of trophic levels
	        for j in range(N_nonzero):
	            trophic_level[indices[0][j]] = trophic_level_nonzero[j] 

	        return trophic_level
	        
	    # function to generate predation matrix from the adjacency matrix
	    def calculate_predation_matrix(adjacency_matrix):
	        """
	        Function that computes the predation matrix from the adjacency matrix
	        :input adjacency matrix: A matrix that contains 0, +1 and -1. +1 denotes that the column species is the prey of the row species. And vice versa for -1.
	        :type adjacency_matrix: int numpy 2darray
	        :return predation_matrix: predation matrix :math:`A, A_{jk} = 1' if :math:`k` is the prey of :math:`j`
	        :rtype predation_matrix: boolean numpy 2darray 
	        """
	        shape = np.shape(adjacency_matrix)
	        predation_matrix = (adjacency_matrix == 1)
	        return predation_matrix
	    
	    # function to add a new species and generate a new adjacency matrix
	    def add_species(adjacency_matrix, N, C):
	        """
	        Function to add a new species :math:`i` to the adjacency matrix to generate a new adjacency matrix of size :math:`i+1`
	        """
	        # intialize new adjacency matrix
	        shape = np.shape(adjacency_matrix)
	        n_i = shape[0]
	        adjacency_matrix_new = np.zeros([n_i+1, n_i+1], dtype=int)
	        adjacency_matrix_new[0:n_i, 0:n_i] = adjacency_matrix

	        # calculate predation matrix
	        predation_matrix = calculate_predation_matrix(adjacency_matrix)
	        # calculate trophic levels
	        trophic_levels = calculate_trophic_level(predation_matrix)

	        # calculate the number of prey species to select
	        x_i = np.random.beta(a=1.0, b=(N**2-1)/(N*(N-1)*C)-1.0)
	        kappa_i = int(np.floor(x_i*n_i))
	        # assign prey species
	        species_j = int(np.floor(n_i*np.random.rand()))
	        # pdb.set_trace()
	        distance_metric = np.abs(trophic_levels-trophic_levels[species_j])
	        prey_species_selected = np.argsort(distance_metric)
	        for i in range(kappa_i):
	            adjacency_matrix_new[n_i, prey_species_selected[i]] = 1
	            adjacency_matrix_new[prey_species_selected[i], n_i] = -1

	        return adjacency_matrix_new
	        
	    # variable that stores the adjacency matrix at each stage
	    
	    accept = False
	    iter_max = 200
	    counter = 0
	    while (not accept) and (counter < iter_max):
	        adjacency_matrix = np.array([[0]], dtype=int)
	        for i in range(2, self.N+1):
	            adjacency_matrix = add_species(adjacency_matrix, 
	            	self.N, self.C)
	        counter = counter + 1
	        if np.abs(np.sum(np.abs(adjacency_matrix))
	        	/(self.N*(self.N-1.0)) - self.C) < tolerance:
	            accept = True
	    if counter == iter_max:
	        print("Warning: the adjacency matrix may not be correct!")
	    
	    return adjacency_matrix

	def generate_community_matrix(self):
		"""
		Function that generates a random community matrix of predator-prey interactions according to the preferential preying model. In the preferential preying model, the adjacency matrix is generated corresponding the PPM algorithm. The individual non-zero elements of the community matrix are generated according to the distribution :math:`|X|` where :math:`X \sim \mathcal{N}(0,\sigma^2)` and multiplying them with the appropriate sign in the signed adjacency matrix.

		:return W: Community matrix associated with this model
		:rtype W: float numpy 2darray
		"""
		adjacency_matrix = self.generate_adjacency_matrix()
		# Initialize the community matrix
		W = np.zeros([self.N, self.N], dtype=float)
		
		# Sample a list of elements as |X| where X is drawn from a gaussian distribution for the lower triangle
		number_of_non_zero_elements = np.sum(np.abs(adjacency_matrix))
		non_zero_elements = self.sigma*np.random.randn(
			number_of_non_zero_elements)
		W[adjacency_matrix!=0] = np.abs(non_zero_elements)
		# make the lower triangle have +ve sign and the upper triangle have negative sign
		W = np.multiply(adjacency_matrix, W)
		
		# Diagonal elements are set to a fixed value
		W[np.diag_indices_from(W)] = -self.d

		return W

class add_predators_random:
    """
	Class definition for adding predators to the an ecosystem to stabilize it. This model takes in four parameters as described below and generates the community matrix :math:`W`.

	:param base_model: Base model to add predators to. This could be any of the previosuly defined random models 
	:param C: Connectance of the graph of interactions. This is the probability that the elements of the appended adjacency matrix is non-zero.
	:param sigma: Standard deviation of the gaussian distribution from which the interaction strengths are sampled.
	:param d: Strength of the self regulation. This is added as a diagonal element in the community matrix. 
	:type base_model: class object
    :type N: int
	:type C: float
	:type sigma: float
	:type d: float

	:ivar N:
	:vartype N: int
	:ivar C: 
	:vartype C: float
	:ivar sigma: 
	:vartype sigma: float
	:ivar d: 
	:vartype d: float
	:ivar adjacency_matrix: Adjacency matrix capturing the network of species-species interactions. This is generated by the function ``adjacency_matrix()``
	:vartype adjacency_matrix: boolean numpy 2darray
	:ivar community_matrix: Community matrix containing pairwise interaction strengths between each pair of species. This is generated by the function ``community_matrix()``
	:vartype community_matrix: float numpy 2darray

	"""
    
    def __init__(self, base_model, N, C, sigma, d):
        self.base_model = base_model
        self.N = int(N)
        self.C = C
        # ensure that the value of C is a fraction
        assert self.C >= 0.0 and self.C <= 1.0, (
            "The connectance C supplied has to be a fraction")
        self.sigma = sigma
        self.d = d
    
    def generate_adjacency_matrix(self):
        """
        Function that appends interactions corresponding to predators into the base model and generates an appended adjacency matrix
        """
        # generate base adjacency matrix
        adjacency_matrix_base = self.base_model.generate_adjacency_matrix()
        if adjacency_matrix_base.dtype == bool:
            adjacency_matrix_base = np.array(adjacency_matrix_base, 
            	dtype=int)
        shape_base = np.shape(adjacency_matrix_base)
        N_base = shape_base[0]
        
        # initialize the adjacency matrix that contains predator interactions
        N_total = N_base+self.N
        adjacency_matrix = np.zeros([N_total, N_total], dtype=int)
        adjacency_matrix[0:N_base, 0:N_base] = adjacency_matrix_base
        
        # append predator interactions
        size_of_top_right_quadrant = N_base*self.N
        elements_top_right_quadrant = -1.0*np.array(
        	np.random.random(size_of_top_right_quadrant) < self.C, dtype=int)
        adjacency_matrix[0:N_base, N_base:N_total] = np.reshape(
        	elements_top_right_quadrant, (N_base, self.N))
        adjacency_matrix[N_base:N_total, 0:N_base] = (-1.0
        	*adjacency_matrix[0:N_base, N_base:N_total].transpose())
        
        return adjacency_matrix
    
    def generate_community_matrix(self):
        """
        Function that generates the community matrix of interactions
        """
        # generate adjacency matrix
        adjacency_matrix = self.generate_adjacency_matrix()
        
        # generate base community matrix
        community_matrix_base = self.base_model.generate_community_matrix()
        shape_base = np.shape(community_matrix_base)
        N_base = shape_base[0]
        
        # initialize the community matrix that contains predator interactions
        N_total = N_base + self.N
        community_matrix = np.zeros([N_total, N_total], dtype=float)
        community_matrix[0:N_base, 0:N_base] = community_matrix_base
        
        # generate the rest of the elements of the community matrix
        top_right_quadrant = np.array(
        	adjacency_matrix[0:N_base, N_base:N_total], dtype=float)
        bottom_left_quadrant = np.array(
        	adjacency_matrix[N_base:N_total, 0:N_base], dtype=float)
        number_of_predatory_interactions = int(np.sum(bottom_left_quadrant))
        interaction_strengths = np.abs(self.sigma
        	*np.random.randn(2*number_of_predatory_interactions))
        top_right_quadrant[top_right_quadrant!=0] = (-1.0
        	*interaction_strengths[0:number_of_predatory_interactions])
        bottom_left_quadrant[bottom_left_quadrant!=0] = (
        	interaction_strengths[number_of_predatory_interactions:])
        community_matrix[0:N_base, N_base:N_total] = top_right_quadrant
        community_matrix[N_base:N_total, 0:N_base] = bottom_left_quadrant
        for i in range(N_base, N_total):
            community_matrix[i,i] = -1.0*self.d
        
        return community_matrix
